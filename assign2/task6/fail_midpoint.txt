I used [2147483641] and [2147483645] to fail midpoint_original test. It failed because [2147483641] is [0b0111 1111 1111 1111 1111 1111 1111 1001] and [2147483645] is [0b0111 1111 1111 1111 1111 1111 1111 1101] so the midpoint of [2147483641] and [2147483645] is expected to be [2147483643] = [0b0111 1111 1111 1111 1111 1111 1111 1011]. However, midpoint_original failed when it computes [(x + y)] because its result is [0b0111 1111 1111 1111 1111 1111 1111 1001 + 0b0111 1111 1111 1111 1111 1111 1111 1101 = 0b1111 1111 1111 1111 1111 1111 1111 0110]. During [x + y], the addition of the two inputs will result in an overflow of [0b1111 1111 1111 1111 1111 1111 1111 0110].

I used [-2147483] and [2147483646] to fail midpoint_A test. It failed because [-2147483] is [0b1101 1111 0011 1011 0110 0101] and [2147483646] is [0b0111 1111 1111 1111 1111 1111 1111 1110] so the midpoint of [-2147483] and [2147483646] is expected to be [1072668081] = [0b0011 1111 1110 1111 1001 1101 1011 0001]. However, midpoint_A failed when it computes [y-x] because its result is [0b0111 1111 1111 1111 1111 1111 1111 1110 - 0b1101 1111 0011 1011 0110 0101 = 0b0111 1111 1111 1111 1111 1111 1111 1110 + 0b0010 0000 1100 0100 1001 1011 = 0b1000 0000 00010 0010 0000 1100 0100 1001 1001]. For [y-x], I converted the x into a positive integer and added the positive x with the y, which resulted me in an overflow.